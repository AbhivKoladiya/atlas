####################################################################################################################
#
# Script: screen_figures.R
# Project: An integrated multi-omic single cell atlas of human B cell identity
# Author: David Glass
# Date: 5-28-20
#
# Purpose: Generate figures for screen main figures
#
# Instructions:
# This script requires the csv generated by screen_preprocess.R
# This script also requires go_parsed.csv
# Install all required packages (see LIBRARIES and/or Versions below)
# Set path (under USER INPUTS) to a unique directory
# Ensure both csv files are in that directory
# Run script
# One can also run the inputs and functions and then scroll down to MAIN
#  to choose which subfigures to generate.
#
# Versions:
# R 3.6.3
# RStudio 1.2.5042
# umap_0.2.5.0 
# ggplot2_3.3.0
# viridis_0.5.1
# dplyr_1.0.0
# data.table_1.12.8
#
#######################################################################################################################



##### USER INPUTS #####

### Path to folder containing csv
path <- "~/example/"



###### LIBRARIES ######

require(umap)
require(ggplot2)
require(viridis)
require(dplyr)
require(data.table)



##### INPUTS #####

factors <- c("panel", "subject", "gate")
conserved.channels <- c("CD45", "CD19", "CD24", "CD38", "CD27", "IgM", "IgD")
gates <- c("Transitional","Naïve","Non-switched","Switched", "Ungated") %>% factor(., .)
strict.gates <- gates[1:4] %>% droplevels()
images.path <- paste0(path, "images/")
gate.colors <- viridis(4)
names(gate.colors) <- strict.gates



##### FUNCTIONS #####

medianHeatmap <- function(med=medians, fa=factors, ip=images.path) {
  # Makes a heatmap of scaled medians
  # Inputs:
  #   med - data.table of medians
  #   fa - vector of column names that are factors
  #   ip - path to images folder
  # Ouputs:
  #  eps file
  col.order <- colnames(med[, !"gate"])[hclust(dist(t(med[, !"gate"])))$order]
  # order varies slightly due to difference in column arrangement of medians
  
  reordered <- med[, c("gate", col.order), with=F] %>%
    melt.data.table(id.vars="gate", variable.name="marker", value.name="expression") %>%
    .[, marker:=factor(marker, levels=unique(marker))] %>%
    .[, gate:=factor(gate, rev(levels(gate)))]
  ggplot(reordered, aes(x=marker, y=gate, fill=expression)) + geom_tile() + theme_bw() +
    scale_fill_viridis(option="B") + labs(x=NULL, y=NULL) +
    theme(panel.grid=element_blank(), axis.text.x=element_text(hjust=1, angle=90))
  ggsave(paste0(ip, "figure_1d.eps"), width=18, height=4)
}


compareDistributions <- function(dt=dat, fa=factors, sg=strict.gates) {
  # Uses the KS test to find which pops are significantly different between gates for each marker
  # Inputs:
  #   dt - data.table with all expression information
  #   fa - vector with factor column names
  #   sg - vector of gate names
  # Outputs:
  #   comparisons - data.table of marker, gate 1, gate 2, p value, and expression difference
  markers <- setdiff(colnames(dt), fa)
  comparisons <- data.table(matrix(ncol=5, nrow=0)) %>%
    setnames(c("marker", "gate1", "gate2", "pvalue", "difference"))
  combinations <- combn(factor(sg, sg), 2)
  n.sample <- min(table(dt[, .(panel, gate, subject)])) # smallest gate for every panel
  set.seed(666)
  subsampled <- dt[, .SD[sample(.N, n.sample)], by=.(gate, panel, subject)] %>%
    .[gate!="Ungated"]
  for (marker in markers) {
    for (i in seq(ncol(combinations))) {
      values.1 <- subsampled[gate==combinations[1,i], marker, with=F] %>%
        na.omit() %>%
        as.matrix() %>%
        as.numeric()
      values.2 <- subsampled[gate==combinations[2,i], marker, with=F] %>%
        na.omit() %>%
        as.matrix() %>%
        as.numeric()
      results <- ks.test(values.1, values.2)
      dif <- dt[gate==combinations[1,i], lapply(.SD, median, na.rm=T), .SDcols=marker] -
        dt[gate==combinations[2,i], lapply(.SD, median, na.rm=T), .SDcols=marker]
      comparisons <- rbind(comparisons, data.table(marker=marker,
                                                   gate1=combinations[1,i],
                                                   gate2=combinations[2,i],
                                                   pvalue=results$p.value,
                                                   difference=dif[[1]]))
    }
  }
  bonferroni.multiplier <- nrow(comparisons)
  comparisons <- comparisons[, pvalue:=pvalue*bonferroni.multiplier] %>%
    .[order(-abs(difference))] %>% 
    .[, comparison:=paste(gate1, gate2, sep=":")] 
  return(comparisons)
}


comparisonHeatmap <- function(com=comparisons, ip=images.path) {
  # Makes a heatmap of comparisons
  # Inputs:
  #   com - data.table of comparisons data
  #   ip - path to images folder
  # Ouputs:
  #  eps file
  
  # only keep significant p-value and difference > 0.1
  com <- com[pvalue<0.005 & abs(difference)>0.1] %>%
    dcast(., marker~comparison, value.var="difference")
  com[is.na(com)] <- 0
  
  reordered <- com[order(rowMeans(com[, !"marker"])), c(1, 5:7, 2:4)] %>%
    melt(id.vars="marker", variable.name="comparison", value.name="difference") %>%
    .[, marker:=factor(marker, levels=unique(marker))] %>%
    .[, comparison:=factor(comparison, levels=unique(comparison))]
  
  div.palette <- rev(c("#0E525E", "#82DDB6", "#FFFAFA", "#CFC3E0", "#533560"))
  lims <- c(-1*max(abs(reordered$difference)), max(abs(reordered$difference)))
  ggplot(reordered, aes(x=marker, y=comparison, fill=difference)) + geom_tile() + theme_bw() +
    scale_fill_gradientn(colors=div.palette, limits=lims) + labs(x=NULL, y=NULL) +
    theme(panel.grid=element_blank(), axis.text.x=element_text(hjust=1, angle=90)) + coord_flip()
  ggsave(paste0(ip, "figure_2a.eps"), width=4, height=12)
}


makeComparisonVolcanoes <- function(ip=images.path, com=comparisons,
                                    go=go.table, term="transport",
                                    threshold=-log10(0.005)) {
  # Makes volcano plots comparing populations, highlighting a specific go term
  # Inputs:
  #   ip - path to images folder
  #   com - data.table of comparisons data
  #   go - data.table with column of markers, and columns of go terms with logicals
  #   term - character vector with go term to highlight in the plots
  #   threshold - -log10(p-value) cutoff for significance
  # Outputs:
  #   The plots
  channels <- go[, term, with=F] %>%
    as.matrix() %>%
    as.logical() %>%
    go$marker[.]
  transformed <- copy(com)
  min.value <- transformed[pvalue>0, min(pvalue)]
  
  transformed[pvalue==0, pvalue:= abs(rnorm(nrow(transformed[pvalue==0]), mean=min.value, sd=min.value/3))]
  transformed[, pvalue:=-log10(pvalue)]
  
  labels <- c("Down - Enriched", "Down", "Insignificant", "Up", "Up - Enriched") %>%
    factor(., .)
  transformed[gate2=="Naïve", `:=`(gate1=gate2,
                                   gate2=gate1,
                                   comparison=paste(gate2, gate1, sep=":"),
                                   difference=-difference)]
  transformed[, difference:=-difference]
  transformed[difference>=0, label:="Up"]
  transformed[difference<0, label:="Down"]
  transformed[difference>=0 & marker %in% channels, label:="Up - Enriched"]
  transformed[difference<0 & marker %in% channels, label:="Down - Enriched"]
  transformed[pvalue<threshold, label:="Insignificant"]
  transformed <- transformed[, label:=factor(label, levels=labels[c(2,3,4,1,5)])] %>% .[order(label)]
  transformed[, label:=factor(label, levels=labels)]
  
  x.lims <- ceiling(max(abs(transformed$difference)) * 10) / 10 %>% c(-1*., .)
  y.lims <- range(transformed$pvalue)
  pal <- rev(c("#8F2D56",  "#D8C0CA", "#181919", "#C3DCE5", "#114B5F"))

  ggplot(transformed, aes(difference, pvalue, color=label)) + geom_point(size=5) +
    facet_wrap(~comparison, nrow=2) +
    scale_color_manual(values=pal) +
    scale_x_continuous(limits=x.lims, breaks=seq(x.lims[1], x.lims[2], x.lims[2]/2)) +
    scale_y_continuous(limits=y.lims) + theme_bw() + theme(legend.position="none")
  ggsave(paste0(ip, "figure_2b.eps"), width=18, height=12)
}


goMeans <- function(m=medians, go=go.table, sg=levels(strict.gates)) {
  # returns table with mean of median values for all markers
  #  associated with each go term for each population
  # Inputs:
  #   m - medians table
  #   go - go table
  #   sg - vector of gate names
  # Ouptuts:
  #  go.means - table with population rows and go columns
  go.cols <- setdiff(colnames(go), "marker")
  go.means <- matrix(nrow=nrow(m), ncol=length(go.cols)) %>%
    data.table() %>%
    setnames(go.cols) %>%
    .[, lapply(.SD, as.numeric)]
  go.means[, gate:=m$gate]
  
  m.cast <- melt(m, id.vars="gate", variable.name="marker") %>%
    dcast.data.table(marker~gate)
  
  for (col in go.cols) {
    channels <- go[, col, with=F] %>%
      as.matrix() %>%
      as.logical() %>%
      go$marker[.]
    scores <- m.cast[marker %in% channels, lapply(.SD, mean), .SDcols=sg] %>%
      as.list()
    for (pop in sg) {
      go.means[gate==pop, (col):=scores[[pop]]]
    }
  }
  return(go.means)
}


makeMarkerLine <- function(ip=images.path, med=medians, go=go.table,
                           go.m=go.means, term="transport", sg=strict.gates) {
  # Makes line graphs of markers across gates
  # Inputs:
  #   ip - images path character vector
  #   med - data.table of marker medians
  #   go - data.table with column of markers, and columns of go terms with logicals
  #   go.m - table with population rows and go columns
  #   term - character vector with go term to highlight in the plots
  #   sg - factor of gate names
  # Outputs:
  #   eps plot
  
  # ID channels where naive has the minimum mean
  naive.min <- med[, lapply(.SD, function(x) which.min(x)==which(med$gate=="Naïve")), .SDcols=!"gate"] %>%
    as.list() %>%
    unlist() %>%
    which() %>%
    names()
  
  # Don't look at those channels where there is a tie for minimum
  not.repeated <- med[, lapply(.SD, function(x) sum(x==min(x))==1), .SDcols=!"gate"] %>%
    as.list() %>%
    unlist() %>%
    which() %>%
    names()
  
  channels <- go[, term, with=F] %>%
    as.matrix() %>%
    as.logical() %>%
    go$marker[.] %>%
    intersect(naive.min) %>%
    intersect(not.repeated)
  
  melt.med <- merge(med[, c(channels, "gate"), with=F], go.m[, c(term, "gate"), with=F], by="gate") %>%
    melt(id.vars="gate", variable.name="marker", value.name="expression") %>%
    .[, gate:=factor(gate, levels(sg))]
  
  ggplot(melt.med, aes(gate, expression, color=marker, group=marker)) +
    geom_line(size=2) + geom_point(size=5) +
    theme_bw() +
    theme(axis.text.x=element_text(angle=90, hjust=1), axis.title=element_blank())
  ggsave(paste0(ip, "figure_2c.eps"), width=6)
}


makeGoLine <- function(ip=images.path, med=medians,
                       go.m=go.means, sg=strict.gates) {
  # Makes line graphs of GO terms across gates
  # Inputs:
  #   ip - images path character vector
  #   med - data.table of marker medians
  #   go.m - table with population rows and go columns
  #   sg - factor of gate names
  # Outputs:
  #   eps plot
  
  # ID GO terms with lowest mean for naive B cells
  channels <- go.m[, lapply(.SD, function(x) which.min(x)==which(go.m$gate=="Naïve")), .SDcols=!"gate"] %>%
    as.list() %>%
    unlist() %>%
    which() %>%
    names()
  
  all.mean <- melt(med, id.vars="gate", variable.name="marker") %>%
    dcast.data.table(marker~gate) %>%
    .[, lapply(.SD, mean), .SDcols=!"marker"] %>%
    melt(variable.name="gate", value.name="all markers")
  
  melt.go <- merge(go.m[, c(channels, "gate"), with=F], all.mean, by="gate") %>%
    melt(id.vars="gate", variable.name="term", value.name="expression") %>%
    .[, gate:=factor(gate, levels=levels(sg))]
  
  ggplot(melt.go, aes(gate, expression, color=term, group=term)) + geom_line(size=2) +
    geom_point(size=5) + theme_bw() +
    theme(axis.text.x=element_text(angle=90, hjust=1), axis.title=element_blank())
  ggsave(paste0(ip, "figure_2d.eps"), width=9)
}


makeMarkerBoxplots <- function(ip=images.path, dt=dat, med=medians, go=go.table, gc=gate.colors, com=comparisons,
                               terms=c("antigen processing and presentation", "humoral immune response"),
                               sg=strict.gates) {
  # Makes box graphs of markers across gates
  # Inputs:
  #   ip - images path character vector
  #   dt - data.table of cytof data
  #   med - data.table of gate medians for markers
  #   go - data.table with column of markers, and columns of go terms with logicals
  #   gc - character vector of hex colors for gates
  #   com - data.table of comparisons data
  #   terms - character vector with go term to highlight in the plots
  #   sg - factor of gate names
  # Outputs:
  #   eps plot
  
  naive.sig.markers <- com[gate1=="Naïve" & pvalue<0.005 & difference > 0.1, unique(marker)] %>%
    c(com[gate2=="Naïve" & pvalue<0.005 & difference < -0.1, unique(marker)])
  ap.channels <- go[, terms[1], with=F] %>%
    as.matrix() %>%
    as.logical() %>%
    go$marker[.]
  h.channels <- go[, terms[2], with=F] %>%
    as.matrix() %>%
    as.logical() %>%
    go$marker[.]
  channels <-  union(ap.channels, h.channels) %>%
    intersect(naive.sig.markers)
  
  temp <- dt[gate!="Ungated", c(channels, "gate"), with=F] %>%
    melt(id.vars="gate", value.name="expression", variable.name="marker", variable.factor=F) %>%
    .[!is.na(expression)] %>%
    .[, gate:=factor(gate, levels=sg)] %>%
    .[, marker:=factor(marker, levels=unique(marker)[c(1, 3, 2, 4, 6, 5)])]
  
  ggplot(temp, aes(marker, expression, fill=gate)) + geom_boxplot(position="dodge", outlier.shape=NA) +
    theme_bw() + scale_fill_manual(values=gc) + scale_y_continuous(limits=c(0, 1.3)) 
  ggsave(paste0(ip, "figure_2e.eps"), width=8, height=2)
}


makeUmaps <- function(dt=dat, ip=paste0(images.path, "umap/"),
                      con=conserved.channels, gc=gate.colors, fa=factors, pan=4) {
  # Makes umaps using conserved channels
  # Inputs:
  #   dt - data.table with all of the data to be clustered
  #   ip - character vector to images path
  #   con - vector of conserved markers
  #   gc - vector of gate colors
  #   fa - vector of factor column names
  #   pan - which panel to use as default for conserved markers
  # Outputs:
  #   png images of files
  if (!dir.exists(ip)) dir.create(ip)
  
  n.sample <- 2500
  subsampled <- copy(dt[, .SD[sample(.N, n.sample)], by=.(panel, subject)])
  umap.out <- umap(subsampled[, con, with=F])
  subsampled[, `:=`(umap.1=umap.out$layout[,1], umap.2=umap.out$layout[,2])]
  gc["Ungated"] <- "#b6b6b6"
  
  # gate
  ggplot(subsampled[panel==pan], aes(umap.1, umap.2)) + geom_density2d(color="#000000", alpha=0.25) +
    geom_point(aes(color=gate)) +
    theme_bw() + scale_color_manual(values=gc) + labs(x=NULL, y=NULL) +
    xlim(min(subsampled$umap.1)-0.5, max(subsampled$umap.1)+0.5) +
    ylim(min(subsampled$umap.2)-1, max(subsampled$umap.2)+1) +
    theme(panel.grid.major=element_blank(), panel.grid.minor=element_blank(), panel.border=element_blank(),
          axis.ticks=element_blank(), axis.text=element_blank(), legend.position="none")
  ggsave(paste0(ip, "figure_3c.png"), width=5, height=5)
  
  # contour alone
  ggplot(subsampled[panel==pan], aes(umap.1, umap.2)) + geom_density2d(color="#000000", alpha=1) + 
    theme_bw() + labs(x=NULL, y=NULL) +
    xlim(min(subsampled$umap.1)-0.5, max(subsampled$umap.1)+0.5) +
    ylim(min(subsampled$umap.2)-1, max(subsampled$umap.2)+1) +
    theme(panel.grid.major=element_blank(), panel.grid.minor=element_blank(), panel.border=element_blank(),
          axis.ticks=element_blank(), axis.text=element_blank(), legend.position="none")
  ggsave(paste0(ip, "figure_3a.png"), width=5, height=5)
  
  for (marker in con) {
    ggplot(subsampled[panel==pan], aes(umap.1, umap.2)) + geom_density2d(color="#000000", alpha=0.25) +
      geom_point(aes(color=eval(parse(text=marker)))) +
      theme_bw() + scale_color_viridis(option="B") + labs(x=NULL, y=NULL) +
      xlim(min(subsampled$umap.1)-0.5, max(subsampled$umap.1)+0.5) +
      ylim(min(subsampled$umap.2)-1, max(subsampled$umap.2)+1) +
      theme(panel.grid.major=element_blank(), panel.grid.minor=element_blank(), panel.border=element_blank(),
            axis.ticks=element_blank(), axis.text=element_blank(), legend.position="none")
    ggsave(paste0(ip, "figure_3b_", marker, ".png"), width=5, height=5)
  }
  
  other.markers <- setdiff(colnames(dt), c(fa, con))
  for (marker in other.markers) {
    temp <- subsampled[!is.na(eval(parse(text=marker)))]
    ggplot(temp, aes(umap.1, umap.2)) + geom_density2d(color="#000000", alpha=0.25) +
      geom_point(aes(color=eval(parse(text=marker)))) +
      theme_bw() + scale_color_viridis(option="B") + labs(x=NULL, y=NULL) +
      xlim(min(temp$umap.1)-0.5, max(temp$umap.1)+0.5) +
      ylim(min(temp$umap.2)-1, max(temp$umap.2)+1) +
      theme(panel.grid.major=element_blank(), panel.grid.minor=element_blank(), panel.border=element_blank(),
            axis.ticks=element_blank(), axis.text=element_blank(), legend.position="none")
    ggsave(paste0(ip, "figure_3b_", marker, ".png"), width=5, height=5)
  }
}


getCorrelations <- function(dt=dat, con=conserved.channels[3:7], threshold=0.3) {
  # finds markers correlated with con above threshold
  # Inputs:
  #   dt - data.table
  #   con - character vector of conserved markers to query
  #   threshold - pearson correlation threshold for markers to keep
  # Outputs:
  #   melted.cor - data.table with marker names and correlation values
  cor.dt <- data.table(matrix(nrow=0, ncol=length(con)+1)) %>%
    setnames(c(con, "marker"))
  for (p in unique(dt$panel)) {
    temp <- dt[panel==p] %>%
      .[, !c("gate", "subject", "panel")]
    temp <- temp[, temp[, colnames(temp)[as.logical(lapply(.SD, function(x) !any(is.na(x))))]], with=F] %>%
      as.matrix()
    cor.dt <-cor(temp, method="pearson") %>%
      as.data.table(keep.rownames="marker") %>%
      .[marker %in% setdiff(colnames(temp), con), c(con, "marker"), with=F] %>%
      rbind(cor.dt)
  }
  melted.cor <- melt(cor.dt) %>%
    .[abs(value)>threshold] %>%
    .[order(value, decreasing=T)]
  return(melted.cor)
}


makeBiaxialGraphs <- function(dt=dat, ip=images.path, gc=gate.colors, fa=factors, pan=4) {
  # Makes RB vs 27 biaxial and bargraph counts quadrants
  # Inputs:
  #   dt - data.table with all of the data to be clustered
  #   ip - character vector to images path
  #   gc - vector of gate colors
  #   fa - vector of column names of factor columns
  #   pan - which panel to use
  # Outputs:
  #   png & eps images of files
  #   prints quadrant counts
  n.sample <- 5000
  subsampled <- copy(dt[, .SD[sample(.N, n.sample)], by=.(panel, subject)]) %>%
    .[CD38<0.3 & panel==pan]
  gc["Ungated"] <- "#b6b6b6"
  
  ggplot(subsampled, aes(CD27, CD45RB, color=gate)) + geom_point(size=2) + 
    theme_bw() + scale_color_manual(values=gc) + theme(legend.position="none") +
    geom_hline(yintercept=0.45, linetype="dashed", size=1) +
    geom_vline(xintercept=0.3, linetype="dashed", size=1) 
  ggsave(paste0(ip, "figure_3d.png"), width=5, height=5)

  subsampled[CD45RB<0.45 & CD27<0.3, quadrant:="I"]
  subsampled[CD45RB>0.45 & CD27<0.3, quadrant:="II"]
  subsampled[CD45RB>0.45 & CD27>0.3, quadrant:="III"]
  subsampled[CD45RB<0.45 & CD27>0.3, quadrant:="IV"]
  
  total.counts <- table(subsampled$quadrant) / nrow(subsampled) * 100 %>%
    as.numeric()
  print("Quandrant percentages:")
  print(total.counts)
  
  counts <- table(subsampled$quadrant, subsampled$gate) %>%
    apply(1, function(x) x/sum(x) * 100) %>%
    as.data.table(keep.rownames="gate") %>%
    melt(id.vars="gate", variable.name="quadrant", value.name="percent") %>%
    .[, quadrant:=factor(quadrant, levels=c("I", "II", "III", "IV"))]
  
  ggplot(counts, aes(quadrant, percent, fill=gate)) + geom_bar(stat="identity") +
    theme_bw() + scale_fill_manual(values=gc) + theme(legend.position="none")
  ggsave(paste0(ip, "figure_3e.eps"), width=3, height=5)
  
  print("Quadrant percentages by gate:")
  print(counts)
}



##### MAIN #####

if (!dir.exists(images.path)) dir.create(images.path)
dat <- fread(paste0(path, "processed_screen.csv"), stringsAsFactors=T) %>%
  .[, panel:=as.factor(panel)] %>%
  .[, gate:=factor(gate, levels(gates))]

medians <- dat[gate!="Ungated", lapply(.SD, median, na.rm=T), by=gate, .SDcols=setdiff(colnames(dat), factors)] %>%
  .[order(gate)] %>%
  .[, gate:=droplevels(gate)]

# Figure 1d
medianHeatmap()

# Figure 2 analysis
comparisons <- compareDistributions()
go.table <- fread(paste0(path, "go_parsed.csv"))
go.means <- goMeans()
# go.means[, lapply(.SD, rank), .SDcols=!"gate"][2] %>%
#   as.list() %>%
#   unlist()
# naive doesn't have the highest mean for any go term, but has second highest
# for `antigen processing and presentation` and `humoral immune response`

# Figure 2a
comparisonHeatmap()
# Figure 2b
makeComparisonVolcanoes()
# Figure 2c
makeMarkerLine()
# Figure 2d
makeGoLine()
# Figure 2e
makeMarkerBoxplots()

# Figure 3 analysis
correlations <- getCorrelations()

# Figure 3a-c
makeUmaps()
# Figure 3d-e
makeBiaxialGraphs()